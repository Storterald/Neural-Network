#pragma once

#include <cstdint>
#include <string_view>

// Generic constants.
constexpr float EPSILON { 1e-8f };
constexpr float LEARNING_RATE { 5e-5f };
constexpr uint32_t MAX_FILE_SIZE { (uint32_t)1e9f };

// Allows a macro to expand 342 times. Credit:
// https://www.scs.stanford.edu/~dm/blog/va-opt.html
#define PARENS ()
#define EXPAND(...) EXPAND4(EXPAND4(EXPAND4(EXPAND4(__VA_ARGS__))))
#define EXPAND4(...) EXPAND3(EXPAND3(EXPAND3(EXPAND3(__VA_ARGS__))))
#define EXPAND3(...) EXPAND2(EXPAND2(EXPAND2(EXPAND2(__VA_ARGS__))))
#define EXPAND2(...) EXPAND1(EXPAND1(EXPAND1(EXPAND1(__VA_ARGS__))))
#define EXPAND1(...) __VA_ARGS__

// Helper macro, creates a code block with everything but the first parameter.
// already contains a ';' at the end of the vararg to make a single line case
// look better, if the codeblock contains multiple lines, they will need to be
// separated using a ';'.
#define CASE(value, ...) value, { __VA_ARGS__; }

// Creates a constexpr if else chain inside a do { ... } while(false) block
// to allow the macro to be inside a block without {}. Also obligates the user
// to put ';' after it keeping a cleaner and more uniform syntax.
#define CONSTEXPR_SWITCH(var, ...)                                              \
        do {                                                                    \
                __VA_OPT__(EXPAND(__CONSTEXPR_SWITCH(var, __VA_ARGS__)))        \
        } while (false)

// The actual macro definition.
#define __CONSTEXPR_SWITCH(var, case1, codeBlock1, ...)                         \
        if constexpr (var == case1)                                             \
                codeBlock1                                                      \
        __VA_OPT__(else __CONSTEXPR_SWITCH2 PARENS (var, __VA_ARGS__))

#define __CONSTEXPR_SWITCH2() __CONSTEXPR_SWITCH

// Extracts the class name from the string generated by '__FUNCSIG__'. The
// function is marked 'consteval' and not 'constexpr' since it should be used
// with the macro below which calls this function with a compiler intrinsic macro.
consteval std::string_view __extractClassName(std::string_view id)
{
        size_t end = id.rfind("::", id.find('('));
        if (end == std::string_view::npos)
                // Not in a class.
                return "";

        size_t start = id.substr(0, end).rfind(' ') + 1;
        while (id[start] == '*' || id[start] == '&' || id[start] == ' ')
                ++start;

        return id.substr(start, end - start);
}

// Extracts the function name from the string generated by '__FUNCSIG__'
consteval std::string_view __extractFuncName(std::string_view id)
{
        size_t start = id.rfind("::", id.find('('));
        if (start == std::string_view::npos)
                // Not in a function.
                return "";

        start += 2;
        size_t end = id.find('(', start);
        return id.substr(start, end - start);
}

#define GET_CLASS_NAME() __extractClassName(__FUNCSIG__)
#define GET_FUNCTION_NAME() __extractFuncName(__FUNCSIG__)